# -*- coding: utf-8 -*-
"""MVP.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13Jk4yFwe_ZcY1mxm1Z1wIvmaSL5Si3uA
"""

# Definindo a classe para a carteira de investimentos do cliente
class Carteira:
  def __init__(self,tickers,quantidades):
    self.tickers = tickers            #Ações da carteira
    self.quantidades = quantidades    #Quantidade de ações na carteira

# Criando duas carteiras para testes
cart1 = Carteira(['NVDA','AAPL','MSFT'],[50,30,15])
cart2 = Carteira(['AAPL','JNJ','GOOGL','JPM'],[15,35,20,15])

# Definindo a classe dos dados do cliente, incluindo a carteira de investimentos
class Cliente:
  def __init__(self,id,nome,perfil,carteira):
    self.id = id                      #Identificação do cliente
    self.nome = nome                  #Nome do cliente
    self.perfil = perfil              #Perfil de investimento do cliente
    self.carteira = carteira          #Carteira de investimento do cliente

# Criando os perfis de teste
clt1 = Cliente('0001','Luis Felipe Vamo','moderado',cart1)
clt2 = Cliente('0002','Gustavo Cuca','arrojado',cart2)

# Exibindo os perfis de teste e os ativos da carteira
print(clt1.id,':',clt1.nome)
print('Ação - Quantidade:')
for i in range(len(clt1.carteira.tickers)):
  print(clt1.carteira.tickers[i],'-',clt1.carteira.quantidades[i])

print('\n'+clt2.id,':',clt2.nome)
print('Ação - Quantidade:')
for i in range(len(clt2.carteira.tickers)):
  print(clt2.carteira.tickers[i],'-',clt2.carteira.quantidades[i])

from sklearn.preprocessing import OneHotEncoder, MinMaxScaler
from sklearn.metrics.pairwise import cosine_similarity
import numpy as np
import pandas as pd

# Importando os dados da base da NASDAQ
nasdaqData = pd.read_csv('/content/drive/MyDrive/Hackathon/nasdaq_screener.csv')

# Tratando os dados para a implementação do algoritmo de recomendação
nasdaqData.rename(columns={'Last Sale': 'LS','Net Change':'NC','% Change':'PC','Market Cap':'MC','IPO Year':'IPOY'}, inplace=True)
nasdaqData['Industry'] = nasdaqData['Industry'].fillna('-')
nasdaqData['Sector'] = nasdaqData['Sector'].fillna('-')
nasdaqData['IPOY'] = nasdaqData['IPOY'].fillna(0)
nasdaqData['Country'] = nasdaqData['Country'].fillna('-')
nasdaqData['PC'] = nasdaqData['PC'].fillna(0)
nasdaqData['MC'] = nasdaqData['MC'].fillna(0)
nasdaqData['LS'] = nasdaqData['LS'].str.replace('$', '', regex=False)
nasdaqData['LS'] = nasdaqData['LS'].astype(float)
nasdaqData['PC'] = nasdaqData['PC'].str.replace('%', '', regex=False)
nasdaqData['PC'] = nasdaqData['PC'].astype(float)
nasdaqData.loc[5639,'PC'] = 0

# Algoritmo de recomendação de ações da bolsa
def recomendar_simbolos(df, symbols_entrada, pesos, top_n):
    """
    Recomenda símbolos similares com base em PC positivo e categorias (Country, Sector, Industry),
    ponderando pela lista de pesos fornecida.

    Parâmetros:
    - df: DataFrame com colunas ['Symbol','Name','LS','NC','PC','MC','Country','IPOY','Volume','Sector','Industry']
    - symbols_entrada: lista de strings com Symbols de entrada
    - pesos: lista de pesos (não normalizados) correspondente aos symbols_entrada
    - top_n: número de símbolos recomendados a retornar

    Retorna:
    - lista de top_n Symbols recomendados
    """

    # Analisando a tendência de crescimento da ação
    df_filtered = df
    df_sign = [np.sign(df['PC'])].copy()

    # Separando dados categóricos e numéricos
    cat_cols = ['Country', 'Sector', 'Industry']
    num_cols = ['PC']

    # One-Hot Encoding para categóricos
    encoder = OneHotEncoder(sparse_output=False)
    cat_features = encoder.fit_transform(df_filtered[cat_cols])

    # Normalizando PC
    scaler = MinMaxScaler()
    num_features = scaler.fit_transform(df_filtered[num_cols])

    # Combinando features
    features = np.hstack([cat_features, num_features])

    # Criando vetor de entrada baseado nos Symbols fornecidos
    # Filtrando df para os symbols de entrada
    df_input = df_filtered[df_filtered['Symbol'].isin(symbols_entrada)].copy()
    if df_input.empty:
        raise ValueError("Nenhum dos symbols de entrada foi encontrado com PC positivo.")

    # Codificando e normalizar input
    cat_input = encoder.transform(df_input[cat_cols])
    num_input = scaler.transform(df_input[num_cols])
    input_features = np.hstack([cat_input, num_input])

    # Aplicando pesos aos vetores de input
    pesos = np.array(pesos).reshape(-1, 1)
    input_features_weighted = input_features * pesos

    # Calculando vetor médio ponderado da entrada
    vetor_entrada = np.mean(input_features_weighted, axis=0).reshape(1, -1)

    # Calculando similaridade com todos os Symbols filtrados
    sim = cosine_similarity(features, vetor_entrada).flatten()

    # Aplicando a tendência de crescimento na similaridade
    S = []
    u = 0
    for i in sim:
      S.append([i*df_sign[0][u]])
      u += 1

    # Criando DataFrame de scores
    df_filtered['score'] = S

    # Excluindo Symbols de entrada
    df_result = df_filtered[~df_filtered['Symbol'].isin(symbols_entrada)]

    # Selecionando top_n símbolos
    top_symbols = df_result.sort_values('score', ascending=False).head(top_n)['Symbol'].tolist()

    return top_symbols

top5_recomendados = recomendar_simbolos(nasdaqData, clt2.carteira.tickers, clt2.carteira.quantidades, top_n=5)
print(top5_recomendados)

